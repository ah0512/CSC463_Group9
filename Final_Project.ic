/* 
   Final Project
   Andrew Mueller & Austin Hamman
   CSC 463 - Dr. Girard
*/

//Handyboard Ports
int LEFT_MOTOR = 0;
int RIGHT_MOTOR = 2;
int ARM_MOTOR = 3;
int REFLECTIVE_FRONTR = 5; //Front-Right Reflective port
int REFLECTIVE_FRONTL = 6; //Front-Left Reflective port
int LIGHT_RIGHT = 4; //RightLight port
int LIGHT_LEFT = 3; //Left Light port
int ELEVATION = 2; //probably not used

int block = 0;
int blockCount = 0;
int turn; //-1 is left, 1 is right
int reset = 1; 

void forward(int power) {    
   motor(RIGHT_MOTOR, power);    
   motor(LEFT_MOTOR, power);
}

void backward(int power) {
   motor(RIGHT_MOTOR, -power);       
   motor(LEFT_MOTOR, -power);
}

void turnLeft(int power) {
   motor(RIGHT_MOTOR, power);    
   motor(LEFT_MOTOR, -power);
}

void turnRight(int power) {
   motor(RIGHT_MOTOR, -power);    
   motor(LEFT_MOTOR, power);   
}

void turnAround(){ //do a 180 turn
   motor(RIGHT_MOTOR, 80);
   motor(LEFT_MOTOR, -80);
   sleep(5.0);
}

void stop() {
   off(RIGHT_MOTOR);
   off(LEFT_MOTOR);
}


void checkIntersection() {
    if((analog(REFLECTIVE_FRONTR) < LINE) && (analog(REFLECTIVE_FRONTL) < LINE)) {
        stop();
        sleep(1.0);
        if((analog(LIGHT_RIGHT) > SOURCE) && !block) {
         turn90DegreesRight();
         turn = reset*1;
        }else if((analog(LIGHT_LEFT) > SOURCE && !block)){
         turn90DegreesLeft();
         turn = reset*(-1);
        }else if(blockInterCount == 0 && turn = 0){
          turn90DegreesLeft();
        }else if(blockInterCount == 0 && turn = 1){
          turn90DegreesRight();
        }else{
         forward(50);
         sleep(0.5);
        }
        if(block){
         blockInterCount++;
        }
    }
}

/*
int checkPath() {
    if((analog(REFLECTIVE_FRONTR) < LINE) && (analog(REFLECTIVE_FRONTL) < LINE)) {
        return 1;
    }else{
      return 0;
    }
   
}

void intersection(){
   if((analog(REFLECTIVE_FRONTR) < LINE) && (analog(REFLECTIVE_FRONTL) < LINE)) {
        stop();
        sleep(1.0);
        if((analog(LIGHT_RIGHT) > SOURCE) && !block) {
         turn90DegreesRight();
         turn = reset*1;
        }else if((analog(LIGHT_LEFT) > SOURCE && !block)){
         turn90DegreesLeft();
         turn = reset*(-1);
        }else if(blockInterCount == 0 && turn == -1){
          turn90DegreesLeft();
        }else if(blockInterCount == 0 && turn == 1){
          turn90DegreesRight();
        }else{
         forward(50);
         sleep(0.5);
        }
   }
}
*/

void checkBlock(){
  while(analog(LIGHT_SENSOR) > SOURCE) {
      checkLine();
      if(analog(LIGHT_SENSOR) > BLOCK && !block){
          grabBlock();
          turnAround();
      }
   }
}

grabBlock(){
   motor(3, 50);
   block = 1;
}

releaseBlock(){
   motor(3, -50);
   block = 0;
   reset = -1;
   blockInterCount = 0;
}

void checkLine(){
   if((analog(REFLECTIVE_FRONTR) < LINE) || (analog(REFLECTIVE_FRONTL) < LINE)){
      forward(50);
   }
   else{
      turnAround();
   }  
}

void turnAround(){ //do a 180 turn
   backward(50);
   sleep(0.1);
   motor(RIGHT_MOTOR, 80);
   motor(LEFT_MOTOR, -80);
   sleep(5.0);
}

turn90DegreesRight(){
  turnRight(80);
  sleep(2.0);
}

turn90DegreesLeft(){
  turnLeft(80);
  sleep(2.0);
}

void main() {
   releaseBlock();
    while(1) {
        checkline();
        //sleep(0.25);
        checkIntersection();
    }
}
