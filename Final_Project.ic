/* 
   Final Project
   Andrew Mueller & Austin Hamman
   CSC 463 - Dr. Girard
*/

//Handyboard Ports
int LEFT_MOTOR = 0;
int RIGHT_MOTOR = 2;
int ARM_MOTOR = 3;
int REFLECTIVE_FRONTR = 4; //Front-Right Reflective port
int REFLECTIVE_FRONTL = 5; //Front-Left Reflective port
int REFLECTIVE_FRONTM = 2;
int LIGHT_RIGHT = 6; //RightLight port
int LIGHT_LEFT = 3; //Left Light port
//int ELEVATION = 2; //probably not used
int TOUCH = 15;

int LINE = 200;
int SOURCE = 245;

int block = 0;
int blockCount = 0;
int turn = 0; //-1 is left, 1 is right
int reset = 1;
int blockInterCount = 0;
int totalBlocks = 0;

void forward(int power) {    
   motor(RIGHT_MOTOR, power);    
   motor(LEFT_MOTOR, power);
}

void backward(int power) {
   motor(RIGHT_MOTOR, -power);       
   motor(LEFT_MOTOR, -power);
}

void turnLeft(int power) {
   motor(RIGHT_MOTOR, power);    
   motor(LEFT_MOTOR, -power);
}

void turnRight(int power) {
   motor(RIGHT_MOTOR, -power);    
   motor(LEFT_MOTOR, power);   
}

/*
void turnAround(){ //do a 180 turn
   motor(RIGHT_MOTOR, 90);
   motor(LEFT_MOTOR, -90);
   sleep(5.0);
}
*/

void stop() {
   off(RIGHT_MOTOR);
   off(LEFT_MOTOR);
}


void checkIntersection() {
    if((analog(REFLECTIVE_FRONTR) >= LINE) && (analog(REFLECTIVE_FRONTL) >= LINE)) {
        stop();
        sleep(0.5);
        if(totalBlocks >= 3){
            forward(70);
        }
        if((analog(LIGHT_RIGHT) <= SOURCE) && !block) {
            turn90DegreesRight();
            turn = reset*1;
            checkBlock();
        }else if((analog(LIGHT_LEFT) <= SOURCE && !block)){
         turn90DegreesLeft();
            turn = reset*(-1);
            checkBlock();
        }else if(blockInterCount == 0 && turn == -1){
          turn90DegreesLeft();
        }else if(blockInterCount == 0 && turn == 1){
          turn90DegreesRight();
        }else{
         forward(70);
        }
        if(block){
         blockInterCount++;
        }
        if(digital(TOUCH) && block){
            releaseBlock();
        }
    }
}

void checkBlock(){
    while(1) {
      motor(ARM_MOTOR, 65);
      checkLine();
      if(digital(TOUCH) && !block){
          grabBlock();
          turn90DegreesLeft();
          break;
        }
   }
}

void grabBlock(){
   motor(ARM_MOTOR, -70);
   block = 1;
}

void releaseBlock(){
   motor(ARM_MOTOR, 65);
   turn90DegreesRight();
   block = 0;
    reset = -1;
    turn = 0;
   blockInterCount = 0;
   totalBlocks++;
}

void checkLine(){
   if((analog(REFLECTIVE_FRONTM) >= LINE)){
      forward(60);
   }
   else {
     while(analog(REFLECTIVE_FRONTM < LINE)){
            turnRight(85);
            if(analog(REFLECTIVE_FRONTL) >= LINE)
               break;
        }
        while(analog(REFLECTIVE_FRONTM) < LINE){
            turnLeft(85);
            if(analog(REFLECTIVE_FRONTR) >= LINE)
               break;
        }
    }
    
    if(digital(TOUCH) && block){
        releaseBlock();
    }
}

void turn90DegreesRight(){
  while(analog(REFLECTIVE_FRONTM < LINE)){
        turnRight(90);
  }
}

void turn90DegreesLeft(){
  while(analog(REFLECTIVE_FRONTM < LINE)){
        turnLeft(90);
  }
}

void main() {
   motor(ARM_MOTOR, -65);
    while(1) {
        //printf("R = %d, M = %d, L = %d \n", analog(REFLECTIVE_FRONTR), analog(REFLECTIVE_FRONTM), analog(REFLECTIVE_FRONTL));
        printf("Left: %d, Right: %d\n",analog(LIGHT_LEFT), analog(LIGHT_RIGHT));
        //sleep(0.1);
        checkLine();
        //sleep(0.5);
        checkIntersection();
    }
}
